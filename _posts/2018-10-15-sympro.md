---
date: 2018-10-15T09:00:00-08:00
title: Symbolic Profiling for Scalable Verification and Synthesis
excerpt: "Our [OOPSLA'18 paper](https://homes.cs.washington.edu/~bornholt/papers/sympro-oopsla18.pdf) introduces performance debugging techniques for automated reasoning tools."
draft: true
---

Automated reasoning tools---verifiers that check program correctness,
synthesizers that generate correct programs, etc.---provide incredibly
powerful ways to construct safe and reliable software.
We've shown how to use verification to [build crash-safe file systems][yggy]
and synthesis to [generate accurate machine models][memsynth],
among other applications.
But the most powerful automated reasoning tool is one that *you* build
for the specific problem you're trying to solve.
While I've shown before how to [build your own synthesis tool][synth],
building a tool that's fast enough for real problems is still black magic.
If we want to give people the ability to build their own automated reasoning tools,
we need to make them understandable and debuggable.

Our new [OOPSLA'18][oopsla] paper,
[*Finding Code That Explodes Under Symbolic Evaluation*][paper],
is our first effort at making automated reasoning tools understandable.
We've developed a new *symbolic profiling* technique
that can help debug the performance of automated reasoning tools.
We've used our symbolic profiler to find bugs in several
real-world automated reasoning tools
and improved their performance by orders of magnitude (up to 300&times;!).
Best of all, our symbolic profiler is already [integrated into Rosette][ros],
so it's available for use right now.

- sympro is a profiler for verification and synthesis tools
- core of the problem is symbolic evaluation and all-paths execution
- identifies hotspots that ordinary tools cannot because it understands these
- great case studies and results
- open source!

## Profiling symbolic evaluation

What makes automated reasoning tools difficult to build?
I think the key problem is that these tools have an unusual execution model
in which they evaluate *all* paths through a program---a verification
tool is searching for a path that makes the program fail,
while a synthesis tool is searching for a program that succeeds on every path.

This all-paths execution style makes 

- sym exec explores all paths
- sometimes paths merge
- controlling this data structure is key to performance
- but we need to make it explicit for debugging
- also states can be complex, so we have a "heap"

## Common anti-patterns and repairs

- algorithms
- data structures
- concretization

- show `list-set` (cite to smten) as cute example

## Case studies

- neutrons
- ferrite was the motivating example
- and more

- user study
- galois

## The future

TK less lame title


[yggy]: https://unsat.cs.washington.edu/projects/yggdrasil/
[memsynth]: https://unsat.cs.washington.edu/projects/memsynth/
[synth]: https://homes.cs.washington.edu/~bornholt/post/building-synthesizer.html
[oopsla]: https://conf.researchr.org/track/splash-2018/splash-2018-OOPSLA
[paper]: https://homes.cs.washington.edu/~bornholt/papers/sympro-oopsla18.pdf
[ros]: https://docs.racket-lang.org/rosette-guide/ch_performance.html?q=rosette#%28part._sec~3asympro%29